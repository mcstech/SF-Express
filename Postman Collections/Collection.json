{
  "info": {
    "_postman_id": "927448a2-2569-486b-a210-522496312f18",
    "name": "Staging",
    "schema": "https://schema.getpostman.com/json/collection/v2.0.0/collection.json"
  },
  "item": [
    {
      "name": "Access Token",
      "event": [
        {
          "listen": "test",
          "script": {
            "id": "bb2bc975-b86d-4659-85ee-575ad66b9801",
            "exec": [
              "const uuid = require('uuid');",
              "",
              "function pack(format) {",
              "  //  discuss at: https://locutus.io/php/pack/",
              "  // original by: Tim de Koning (https://www.kingsquare.nl)",
              "  //    parts by: Jonas Raoni Soares Silva (https://www.jsfromhell.com)",
              "  // bugfixed by: Tim de Koning (https://www.kingsquare.nl)",
              "  //      note 1: Float encoding by: Jonas Raoni Soares Silva",
              "  //      note 1: Home: https://www.kingsquare.nl/blog/12-12-2009/13507444",
              "  //      note 1: Feedback: phpjs-pack@kingsquare.nl",
              "  //      note 1: \"machine dependent byte order and size\" aren't",
              "  //      note 1: applicable for JavaScript; pack works as on a 32bit,",
              "  //      note 1: little endian machine.",
              "  //   example 1: pack('nvc*', 0x1234, 0x5678, 65, 66)",
              "  //   returns 1: '\\u00124xVAB'",
              "  //   example 2: pack('H4', '2345')",
              "  //   returns 2: '#E'",
              "  //   example 3: pack('H*', 'D5')",
              "  //   returns 3: 'Õ'",
              "  //   example 4: pack('d', -100.876)",
              "  //   returns 4: \"\\u0000\\u0000\\u0000\\u0000\\u00008YÀ\"",
              "  //        test: skip-1",
              "  let formatPointer = 0",
              "  let argumentPointer = 1",
              "  let result = ''",
              "  let argument = ''",
              "  let i = 0",
              "  let r = []",
              "  let instruction, quantifier, word, precisionBits, exponentBits, extraNullCount",
              "  // vars used by float encoding",
              "  let bias",
              "  let minExp",
              "  let maxExp",
              "  let minUnnormExp",
              "  let status",
              "  let exp",
              "  let len",
              "  let bin",
              "  let signal",
              "  let n",
              "  let intPart",
              "  let floatPart",
              "  let lastBit",
              "  let rounded",
              "  let j",
              "  let k",
              "  let tmpResult",
              "  while (formatPointer < format.length) {",
              "    instruction = format.charAt(formatPointer)",
              "    quantifier = ''",
              "    formatPointer++",
              "    while ((formatPointer < format.length) && (format.charAt(formatPointer)",
              "      .match(/[\\d*]/) !== null)) {",
              "      quantifier += format.charAt(formatPointer)",
              "      formatPointer++",
              "    }",
              "    if (quantifier === '') {",
              "      quantifier = '1'",
              "    }",
              "    // Now pack variables: 'quantifier' times 'instruction'",
              "    switch (instruction) {",
              "      case 'a':",
              "      case 'A':",
              "        // NUL-padded string",
              "        // SPACE-padded string",
              "        if (typeof arguments[argumentPointer] === 'undefined') {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': not enough arguments')",
              "        } else {",
              "          argument = String(arguments[argumentPointer])",
              "        }",
              "        if (quantifier === '*') {",
              "          quantifier = argument.length",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          if (typeof argument[i] === 'undefined') {",
              "            if (instruction === 'a') {",
              "              result += String.fromCharCode(0)",
              "            } else {",
              "              result += ' '",
              "            }",
              "          } else {",
              "            result += argument[i]",
              "          }",
              "        }",
              "        argumentPointer++",
              "        break",
              "      case 'h':",
              "      case 'H':",
              "        // Hex string, low nibble first",
              "        // Hex string, high nibble first",
              "        if (typeof arguments[argumentPointer] === 'undefined') {",
              "          throw new Error('Warning: pack() Type ' + instruction + ': not enough arguments')",
              "        } else {",
              "          argument = arguments[argumentPointer]",
              "        }",
              "        if (quantifier === '*') {",
              "          quantifier = argument.length",
              "        }",
              "        if (quantifier > argument.length) {",
              "          const msg = 'Warning: pack() Type ' + instruction + ': not enough characters in string'",
              "          throw new Error(msg)",
              "        }",
              "        for (i = 0; i < quantifier; i += 2) {",
              "          // Always get per 2 bytes...",
              "          word = argument[i]",
              "          if (((i + 1) >= quantifier) || typeof argument[i + 1] === 'undefined') {",
              "            word += '0'",
              "          } else {",
              "            word += argument[i + 1]",
              "          }",
              "          // The fastest way to reverse?",
              "          if (instruction === 'h') {",
              "            word = word[1] + word[0]",
              "          }",
              "          result += String.fromCharCode(parseInt(word, 16))",
              "        }",
              "        argumentPointer++",
              "        break",
              "      case 'c':",
              "      case 'C':",
              "        // signed char",
              "        // unsigned char",
              "        // c and C is the same in pack",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(arguments[argumentPointer])",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 's':",
              "      case 'S':",
              "      case 'v':",
              "        // signed short (always 16 bit, machine byte order)",
              "        // unsigned short (always 16 bit, machine byte order)",
              "        // s and S is the same in pack",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 'n':",
              "        // unsigned short (always 16 bit, big endian byte order)",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning: pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 'i':",
              "      case 'I':",
              "      case 'l':",
              "      case 'L':",
              "      case 'V':",
              "        // signed integer (machine dependent size and byte order)",
              "        // unsigned integer (machine dependent size and byte order)",
              "        // signed long (always 32 bit, machine byte order)",
              "        // unsigned long (always 32 bit, machine byte order)",
              "        // unsigned long (always 32 bit, little endian byte order)",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 'N':",
              "        // unsigned long (always 32 bit, big endian byte order)",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 24 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 16 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] >> 8 & 0xFF)",
              "          result += String.fromCharCode(arguments[argumentPointer] & 0xFF)",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 'f':",
              "      case 'd':",
              "        // float (machine dependent size and representation)",
              "        // double (machine dependent size and representation)",
              "        // version based on IEEE754",
              "        precisionBits = 23",
              "        exponentBits = 8",
              "        if (instruction === 'd') {",
              "          precisionBits = 52",
              "          exponentBits = 11",
              "        }",
              "        if (quantifier === '*') {",
              "          quantifier = arguments.length - argumentPointer",
              "        }",
              "        if (quantifier > (arguments.length - argumentPointer)) {",
              "          throw new Error('Warning:  pack() Type ' + instruction + ': too few arguments')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          argument = arguments[argumentPointer]",
              "          bias = Math.pow(2, exponentBits - 1) - 1",
              "          minExp = -bias + 1",
              "          maxExp = bias",
              "          minUnnormExp = minExp - precisionBits",
              "          status = isNaN(n = parseFloat(argument)) || n === -Infinity || n === +Infinity ? n : 0",
              "          exp = 0",
              "          len = 2 * bias + 1 + precisionBits + 3",
              "          bin = new Array(len)",
              "          signal = (n = status !== 0 ? 0 : n) < 0",
              "          n = Math.abs(n)",
              "          intPart = Math.floor(n)",
              "          floatPart = n - intPart",
              "          for (k = len; k;) {",
              "            bin[--k] = 0",
              "          }",
              "          for (k = bias + 2; intPart && k;) {",
              "            bin[--k] = intPart % 2",
              "            intPart = Math.floor(intPart / 2)",
              "          }",
              "          for (k = bias + 1; floatPart > 0 && k; --floatPart) {",
              "            (bin[++k] = ((floatPart *= 2) >= 1) - 0)",
              "          }",
              "          for (k = -1; ++k < len && !bin[k];) {}",
              "          // @todo: Make this more readable:",
              "          const key = (lastBit = precisionBits - 1 +",
              "            (k =",
              "              (exp = bias + 1 - k) >= minExp &&",
              "              exp <= maxExp ? k + 1 : bias + 1 - (exp = minExp - 1))) + 1",
              "          if (bin[key]) {",
              "            if (!(rounded = bin[lastBit])) {",
              "              for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]) {}",
              "            }",
              "            for (j = lastBit + 1; rounded && --j >= 0;",
              "              (bin[j] = !bin[j] - 0) && (rounded = 0)) {}",
              "          }",
              "          for (k = k - 2 < 0 ? -1 : k - 3; ++k < len && !bin[k];) {}",
              "          if ((exp = bias + 1 - k) >= minExp && exp <= maxExp) {",
              "            ++k",
              "          } else {",
              "            if (exp < minExp) {",
              "              if (exp !== bias + 1 - len && exp < minUnnormExp) {",
              "                // \"encodeFloat::float underflow\"",
              "              }",
              "              k = bias + 1 - (exp = minExp - 1)",
              "            }",
              "          }",
              "          if (intPart || status !== 0) {",
              "            exp = maxExp + 1",
              "            k = bias + 2",
              "            if (status === -Infinity) {",
              "              signal = 1",
              "            } else if (isNaN(status)) {",
              "              bin[k] = 1",
              "            }",
              "          }",
              "          n = Math.abs(exp + bias)",
              "          tmpResult = ''",
              "          for (j = exponentBits + 1; --j;) {",
              "            tmpResult = (n % 2) + tmpResult",
              "            n = n >>= 1",
              "          }",
              "          n = 0",
              "          j = 0",
              "          k = (tmpResult = (signal ? '1' : '0') + tmpResult + (bin",
              "            .slice(k, k + precisionBits)",
              "            .join(''))",
              "          ).length",
              "          r = []",
              "          for (; k;) {",
              "            n += (1 << j) * tmpResult.charAt(--k)",
              "            if (j === 7) {",
              "              r[r.length] = String.fromCharCode(n)",
              "              n = 0",
              "            }",
              "            j = (j + 1) % 8",
              "          }",
              "          r[r.length] = n ? String.fromCharCode(n) : ''",
              "          result += r.join('')",
              "          argumentPointer++",
              "        }",
              "        break",
              "      case 'x':",
              "        // NUL byte",
              "        if (quantifier === '*') {",
              "          throw new Error('Warning: pack(): Type x: \\'*\\' ignored')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          result += String.fromCharCode(0)",
              "        }",
              "        break",
              "      case 'X':",
              "        // Back up one byte",
              "        if (quantifier === '*') {",
              "          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')",
              "        }",
              "        for (i = 0; i < quantifier; i++) {",
              "          if (result.length === 0) {",
              "            throw new Error('Warning: pack(): Type X:' + ' outside of string')",
              "          } else {",
              "            result = result.substring(0, result.length - 1)",
              "          }",
              "        }",
              "        break",
              "      case '@':",
              "        // NUL-fill to absolute position",
              "        if (quantifier === '*') {",
              "          throw new Error('Warning: pack(): Type X: \\'*\\' ignored')",
              "        }",
              "        if (quantifier > result.length) {",
              "          extraNullCount = quantifier - result.length",
              "          for (i = 0; i < extraNullCount; i++) {",
              "            result += String.fromCharCode(0)",
              "          }",
              "        }",
              "        if (quantifier < result.length) {",
              "          result = result.substring(0, quantifier)",
              "        }",
              "        break",
              "      default:",
              "        throw new Error('Warning: pack() Type ' + instruction + ': unknown format code')",
              "    }",
              "  }",
              "  if (argumentPointer < arguments.length) {",
              "    const msg2 = 'Warning: pack(): ' + (arguments.length - argumentPointer) + ' arguments unused'",
              "    throw new Error(msg2)",
              "  }",
              "  return result",
              "}",
              "",
              "function getSignature(token, timestamp, nonce, encryptedMsg) {",
              "    try {",
              "        const str = `${token}${timestamp}${nonce}${encryptedMsg}`;",
              "        console.log('join string', str);",
              "        return CryptoJS.SHA256(str).toString();",
              "    } catch (err) {",
              "        console.error(err.message)",
              "    }",
              "}",
              "",
              "class AesCrypt {",
              "    key;",
              "    constructor(k) {",
              "        // console.log('To be encoded:', k);",
              "        const decoded = atob(`${k}=`);",
              "        this.key = decoded.replace(/\\s/gi, '+');",
              "        // console.log('decoded', this.key.replace(/\\s/gi, '+'));",
              "        // console.log('encoded', btoa(this.key));",
              "    }",
              "    async encrypt(text, appid) {",
              "        try {",
              "            const random = await this.getRandomStr();",
              "            const packedText = await pack('N', text.length);",
              "",
              "            console.log('packed', packedText);",
              "",
              "            const data = `${random}${packedText}${text}${appid}`;",
              "            // const txt = `${text}`;",
              "            console.log('random+text+appid', data);",
              "            const iv = this.key.substr(0, 16);",
              "            // const iv = CryptoJS.lib.WordArray.create(this.key);",
              "            const dataWA = CryptoJS.enc.Utf8.parse(data);",
              "            const keyWA = CryptoJS.enc.Utf8.parse(this.key);",
              "            const ciphertext = CryptoJS",
              "                .AES",
              "                .encrypt(data, keyWA, {",
              "                    iv: CryptoJS.enc.Utf8.parse(iv),",
              "                    padding: CryptoJS.pad.Pkcs7,",
              "                    mode: CryptoJS.mode.CBC,",
              "                })",
              "                // .ciphertext;",
              "            // const ivCiphertext = iv.clone().concat(ciphertext);",
              "            // const ivCiphertextB64 = ivCiphertext.toString();",
              "            console.log('AES encrypted message', ciphertext.toString());",
              "            return ciphertext.toString();",
              "        } catch (err) {",
              "            console.log('AesCrpty err', err.message);",
              "        }",
              "    }",
              "    async decrypt(encrypted, appid) {",
              "        try {",
              "            const iv = this.key.substr(0, 16);",
              "            const dataWA = CryptoJS.enc.Base64.parse(encrypted);",
              "            const keyWA = CryptoJS.enc.Base64.parse(this.key);",
              "            const ciphertext = CryptoJS",
              "                .AES",
              "                .decrypt(dataWA, keyWA, {iv: iv})",
              "                .ciphertext;",
              "            const ivCiphertext = iv.clone().concat(ciphertext);",
              "            const ivCiphertextB64 = ivCiphertext.toString(CryptoJS.enc.Base64);",
              "            console.log('AES decrypted message', ivCiphertextB64);",
              "            return ivCiphertextB64;",
              "        } catch (err) {",
              "            console.error(err.message);",
              "        }",
              "    }",
              "    async getRandomStr() {",
              "        let str = '';",
              "        const str_pol = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz';",
              "        const max = str_pol.length - 1;",
              "        for (let i = 0; i < 16; i++) {",
              "            const r = await this.mtRand(0, max);",
              "            str = str + str_pol[r];",
              "        }",
              "        return str;",
              "    }",
              "    mtRand (min, max) {",
              "        const argc = arguments.length;",
              "        if (argc === 0) {",
              "            min = 0;",
              "            max = 2147483647;",
              "        } else if (argc === 1) {",
              "            throw new Error('Warning: mt_rand() expects exactly 2 parameters, 1 given');",
              "        } else {",
              "            min = parseInt(min, 10);",
              "            max = parseInt(max, 10);",
              "        }",
              "        return Math.floor(Math.random() * (max - min + 1)) + min;",
              "    }",
              "}",
              "",
              "class BizMsgCrypt {",
              "    token;",
              "    encodingAesKey;",
              "    appId;",
              "    constructor(token, encodingAesKey, appId) {",
              "        this.token = token;",
              "        if (encodingAesKey.length != 43) {",
              "            throw new Error('invalid aes key');",
              "        }",
              "        this.encodingAesKey = encodingAesKey;",
              "\t\tthis.appId = appId;",
              "    }",
              "    async encryptMsg(replyMsg, timestamp, nonce) {",
              "        const ac = new AesCrypt(this.encodingAesKey);",
              "        const encrypt = await ac.encrypt(replyMsg, this.appId);",
              "        const signature = await getSignature(this.token, timestamp, nonce, encrypt);",
              "",
              "        return {",
              "            encrypt,",
              "            signature,",
              "            timestamp,",
              "            nonce,",
              "        };",
              "    }",
              "    async decryptMsg(timestamp, nonce, encrypt) {",
              "        const ac = new AesCrypt(this.encodingAesKey);",
              "        const decrypt = await ac.decrypt(encrypt, this.appId);",
              "    }",
              "}",
              "",
              "pm.test(\"Is valid and has zero error\", () => {",
              "    const responseJson = pm.response.json();",
              "",
              "    pm.expect(pm.response.code).to.eql(200);",
              "    pm.expect(responseJson.apiErrorMsg).to.eql(null);",
              "});",
              "",
              "pm.test(\"The response has all properties\", () => {",
              "    const responseJson = pm.response.json();",
              "    if (responseJson.apiResultData) {",
              "        const token = responseJson.apiResultData.accessToken;",
              "        const expireIn = responseJson.apiResultData.expireIn;",
              "        const nonce = uuid.v4();",
              "        ",
              "        pm.expect(responseJson.apiResultData).to.be.a('object');",
              "        pm.expect(token).to.be.a('string');",
              "",
              "        pm.collectionVariables.set(\"token\", token);",
              "        pm.collectionVariables.set(\"expireIn\", expireIn);",
              "        pm.collectionVariables.set(\"nonce\", nonce);",
              "",
              "    }",
              "});",
              "",
              "pm.test(\"has all collection variables set\", () => {",
              "    const aesKey = pm.collectionVariables.get(\"aesKey\");",
              "    const appKey = pm.collectionVariables.get(\"appKey\");",
              "    const customerCode = pm.collectionVariables.get(\"customerCode\");",
              "    const token = pm.collectionVariables.get(\"token\");",
              "    const nonce = pm.collectionVariables.get(\"nonce\");",
              "",
              "    pm.expect(aesKey).to.be.a('string');",
              "    pm.expect(appKey).to.be.a('string');",
              "    pm.expect(customerCode).to.be.a('string');",
              "    pm.expect(token).to.be.a('string');",
              "    pm.expect(nonce).to.be.a('string');",
              "});",
              "",
              "pm.test(\"body request and signature are encrypted\", async () => {",
              "    const aesKey = pm.collectionVariables.get(\"aesKey\");",
              "    const time = (new Date()).getTime();",
              "    const appKey = pm.collectionVariables.get(\"appKey\");",
              "    const customerCode = pm.collectionVariables.get(\"customerCode\");",
              "    const token = pm.collectionVariables.get(\"token\");",
              "    const nonce = pm.collectionVariables.get(\"nonce\");",
              "",
              "    const pc = new BizMsgCrypt(token, aesKey, appKey);",
              "    const data = {",
              "        requestId: '1614077277245',",
              "        version: '',",
              "        customerCode: 'ICRME00009798',",
              "        // sfWaybillNo: 'SF1324481972744',",
              "        obj: {",
              "            customerOrderNo: '1627293897271455',",
              "        },",
              "        // interProductCode: 'INT0007',",
              "        // parcelQuantity: 1,",
              "        // paymentInfo: {",
              "        //     payMethod: 1,",
              "        //     payMonthCard: '',",
              "        //     taxPayMethod: '2',",
              "        //     taxPayMonthCard: ''",
              "        // },",
              "        // senderInfo: {",
              "        //     address: '306 S BRYN MAWR AVE',",
              "        //     cargoType: 1,",
              "        //     certCardNo: '',",
              "        //     certType: '',",
              "        //     regionSecond: '11A',",
              "        //     company: '',",
              "        //     contact: '姓名测试',",
              "        //     country: 'SG',",
              "        //     regionThird: '',",
              "        //     email: 'iuop@test.com',",
              "        //     eori: '',",
              "        //     phoneAreaCode: '65',",
              "        //     phoneNo: '54875485',",
              "        //     postCode: '759973',",
              "        //     regionFirst: 'Admiralty Road East',",
              "        //     telAreaCode: '86',",
              "        //     telNo: '9516168888',",
              "        //     vat: ''",
              "        // },",
              "        // receiverInfo: {",
              "        //     address: '新加坡 详细地址',",
              "        //     cargoType: 1,",
              "        //     certCardNo: '',",
              "        //     certType: '',",
              "        //     regionSecond: '106A',",
              "        //     company: '顺丰速运',",
              "        //     contact: '李想',",
              "        //     country: 'SG',",
              "        //     regionThird: '',",
              "        //     email: 'iuop@test.com',",
              "        //     eori: '',",
              "        //     phoneAreaCode: '65',",
              "        //     phoneNo: '54875485',",
              "        //     postCode: '536727',",
              "        //     regionFirst: 'Ah Soo Walk',",
              "        //     telAreaCode: '86',",
              "        //     telNo: '9516168888',",
              "        //     vat: ''",
              "        // },",
              "        // customsInfo: {",
              "        //     aesNo: '',",
              "        //     businessRemark: '',",
              "        //     customsBatch: '',",
              "        //     harmonizedCode: '',",
              "        //     senderReasonContent: '',",
              "        //     tradeCondition: ''",
              "        // },",
              "        // parcelInfoList: [",
              "        //     {",
              "        //         amount: 0.1,",
              "        //         brand: '',",
              "        //         currency: '',",
              "        //         goodsCode: '',",
              "        //         goodsDesc: '',",
              "        //         goodsUrl: '',",
              "        //         hsCode: '',",
              "        //         name: 'iPhone',",
              "        //         originCountry: 'SG',",
              "        //         productCustomsNo: '',",
              "        //         productRecordNo: '',",
              "        //         quantity: 1,",
              "        //         stateBarCode: '',",
              "        //         unit: '个'",
              "        //     }",
              "        // ],",
              "    };",
              "    const strData = JSON.stringify(data);",
              "    const result = await pc.encryptMsg(strData, time, nonce);",
              "",
              "    pm.collectionVariables.set(\"signature\", result.signature);",
              "    pm.collectionVariables.set(\"request_body\", result.encrypt);",
              "    pm.collectionVariables.set(\"timestamp\", result.timestamp);",
              "});",
              "",
              ""
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "3dcb240f-3d17-482d-9010-96a4f29e77e2",
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      },
      "request": {
        "method": "GET",
        "header": [
          {
            "key": "lang",
            "value": "en",
            "type": "text"
          }
        ],
        "url": {
          "raw": "{{URL}}/openapi/api/token?appKey={{appKey}}&appSecret={{appSecret}}",
          "host": [
            "{{URL}}"
          ],
          "path": [
            "openapi",
            "api",
            "token"
          ],
          "query": [
            {
              "key": "appKey",
              "value": "{{appKey}}"
            },
            {
              "key": "appSecret",
              "value": "{{appSecret}}"
            }
          ]
        }
      },
      "response": [
        {
          "id": "9a8fa4b7-f070-4e84-8226-cfc7450c390a",
          "name": "Response Example",
          "originalRequest": {
            "method": "GET",
            "header": [
              {
                "key": "lang",
                "value": "en",
                "type": "text"
              }
            ],
            "url": {
              "raw": "{{URL}}/openapi/api/token?appKey={{appKey}}&appSecret={{appSecret}}",
              "host": [
                "{{URL}}"
              ],
              "path": [
                "openapi",
                "api",
                "token"
              ],
              "query": [
                {
                  "key": "appKey",
                  "value": "{{appKey}}"
                },
                {
                  "key": "appSecret",
                  "value": "{{appSecret}}"
                }
              ]
            }
          },
          "status": "OK",
          "code": 200,
          "_postman_previewlanguage": "json",
          "header": [
            {
              "key": "Date",
              "value": "Wed, 16 Mar 2022 06:41:38 GMT"
            },
            {
              "key": "Content-Type",
              "value": "application/json"
            },
            {
              "key": "Content-Length",
              "value": "173"
            },
            {
              "key": "X-Kong-Response-Latency",
              "value": "34"
            },
            {
              "key": "Server",
              "value": "kong/2.5.0"
            },
            {
              "key": "Via",
              "value": "1.1 google"
            }
          ],
          "cookie": [],
          "responseTime": null,
          "body": "{\n    \"apiResultCode\": 0,\n    \"apiErrorMsg\": null,\n    \"apiTimestamp\": 1647412898115,\n    \"apiResultData\": {\n        \"accessToken\": \"auth_fba5c391-a751-4f47-a394-c6f0bb3c4130_1638339241848\",\n        \"expireIn\": 7200\n    }\n}"
        }
      ]
    },
    {
      "name": "Order",
      "event": [
        {
          "listen": "prerequest",
          "script": {
            "id": "035bd76c-7845-4826-b3a5-38f116a7aaee",
            "exec": [
              "pm.test(\"body request and signature are set\", async () => {",
              "    const signature = pm.collectionVariables.get(\"signature\");",
              "    const timestamp = pm.collectionVariables.get(\"timestamp\");",
              "    console.log(signature);",
              "});"
            ],
            "type": "text/javascript"
          }
        },
        {
          "listen": "test",
          "script": {
            "id": "ebc30292-caf8-402c-98dc-19b9af6c1967",
            "exec": [
              "console.log('after', pm.collectionVariables.get(\"signature\"));",
              ""
            ],
            "type": "text/javascript"
          }
        }
      ],
      "id": "ef01cbc0-d999-4b80-ad81-bea4e181be83",
      "protocolProfileBehavior": {
        "disableBodyPruning": true
      },
      "request": {
        "method": "POST",
        "header": [
          {
            "key": "appKey",
            "value": "{{appKey}}",
            "type": "text"
          },
          {
            "key": "token",
            "value": "{{token}}",
            "type": "text"
          },
          {
            "key": "timestamp",
            "value": "{{timestamp}}",
            "type": "text"
          },
          {
            "key": "nonce",
            "value": "{{nonce}}",
            "type": "text"
          },
          {
            "key": "signature",
            "value": "{{signature}}",
            "type": "text"
          },
          {
            "key": "msgType",
            "value": "IUOP_CREATE_ORDER",
            "type": "text"
          },
          {
            "key": "Content-Type",
            "value": "application/json",
            "type": "text"
          }
        ],
        "body": {
          "mode": "raw",
          "raw": "{{request_body}}",
          "options": {
            "raw": {
              "language": "json"
            }
          }
        },
        "url": "{{URL}}/openapi/api/dispatch/"
      },
      "response": []
    }
  ],
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "id": "dc91f065-0bc3-4f3e-9825-edf558754954",
        "type": "text/javascript",
        "exec": [
          ""
        ]
      }
    },
    {
      "listen": "test",
      "script": {
        "id": "17becd51-827a-4819-b11d-46e28f9a3560",
        "type": "text/javascript",
        "exec": [
          ""
        ]
      }
    }
  ],
  "variable": [
    {
      "id": "05498f39-95b6-4c95-b511-43c0b6d7a748",
      "key": "URL",
      "value": "http://api-ifsp.sit.sf.global",
      "type": "string"
    },
    {
      "id": "140319cb-d8dd-48e2-83e6-6d37417de21c",
      "key": "appKey",
      "value": "cdd169d87a4698d314754a79f180308a",
      "type": "string"
    },
    {
      "id": "4af3606f-6af9-404a-b8b8-97bc8c9f4557",
      "key": "appSecret",
      "value": "69fb3e868a45d0bdd5b0de0ea1db6ece",
      "type": "string"
    },
    {
      "id": "aef4598a-2369-41d2-ba3c-5868f178760d",
      "key": "customerCode",
      "value": "ICRME000SRN93",
      "type": "string"
    },
    {
      "id": "f53e7793-a635-4f80-86df-60dac11ae284",
      "key": "aesKey",
      "value": "oI1YdU1cb1YC70HVjZRa3wXBLUsrIUYr5lDh0gFrMbe",
      "type": "string"
    },
    {
      "id": "fb96d6dc-01c1-4df2-b904-5c2520d65070",
      "key": "token",
      "value": "",
      "type": "string"
    },
    {
      "id": "a2991bbd-4edd-48ad-b9e3-53c573ec3628",
      "key": "expireIn",
      "value": "",
      "type": "string"
    },
    {
      "id": "f3823fe9-5cf5-4cd4-9c8d-7e8ed1ac645e",
      "key": "nonce",
      "value": "",
      "type": "string"
    },
    {
      "id": "cbb95c7c-d927-469f-933b-2dc5ad8ea1e6",
      "key": "timestamp",
      "value": ""
    },
    {
      "id": "31cf497a-cf9a-4350-a811-953b1aa3e88f",
      "key": "request_body",
      "value": "null",
      "type": "string"
    },
    {
      "id": "666eb2ef-1b5b-4cdc-99b3-ec9ed6cfdeae",
      "key": "signature",
      "value": "null",
      "type": "string"
    }
  ]
}